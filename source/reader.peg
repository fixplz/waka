{
  function asSeq(atoms) {
    if(atoms.length > 1) return { seq: atoms }
    return atoms[0]
  }
  function atom(bind, expr, op) {
    var el =
      op == '+' ? { many: expr }
      : op == '*' ? { any: expr }
      : op == '?' ? { opt: expr }
      : expr
    if(bind) el.bind = bind
    return el
  }
  function cat(arr) {
    return arr.join('')
  }
}


Start =
  sp
  init:JSEmbed?
  rules:Rule+
  { rules: rules, init: init, }
;

Rule =
  name:RuleHead
  eq
  %anc
  def:Expr
  semi
  { name: name, def: def }
;

RuleHead = n:word sp { n } ;

Expr =
  left:ExprAction
  r:(
    tail:(
      slash 
      e:ExprAction {e}
      )+
    { alt: [left].concat(tail) }
  /
    { left }
  )
  { r }
;

ExprAction =
  body:ExprSeq?
  r:(
    isobj:JSIsObj
    format:JSEmbed
    { format: isobj ? '{' + format.trim() + '}' : format.trim(),
      of: body }
  /
    { body }
  )
  { r }
;

ExprSeq =
  atoms:ExprAtom+
  { asSeq(atoms) }
;

ExprAtom =
  bind:(n:word col {n})?
  expr:( Ref / Range / Literal / ExprParens )
  op:[?*+]? sp
  { atom(bind, expr, op) }
/ 
  op:[&!]
  expr:( Ref / Range / Literal / ExprParens ) sp
  { lookahead: expr, not: op == '!' }
/
  '%anc' sp { anchor: true }
;

Ref = n:word { ref: n } ;
Literal = s:str { str: s } ;
ExprParens = '(' sp %anc e:Expr ')' { e } ;

Range =
  '['
  %anc
  not:'^'? sp
  rs:(
    from:rangechar '-' to:rangechar sp
    { from: from, to: to }
  / 
    chars:( c:rangechar+ sp { cat(c) } )+
    { oneof: cat(chars) }
  )*
  ']'
  { range: rs, not: not == '^' }
;

rangechar = '\\' any / [^\[\]\ \^] ;

JSEmbed =
  '{'
  e:embed
  '}' sp
  { e }
;

JSIsObj =
  &( '{' sp word ' '* col )
  { true }
/
  { false }
;

word = [a-z A-Z _][a-z A-Z 0-9 _]* ;

str = 
  ["] x:('\\' any / [^"])* ["] { x }
/ ['] x:('\\' any / [^'])* ['] { x }
;

embed =
  [^{}"']*
  (
    ( '{' embed '}' / str )
    [^{}"']*
  )* ;

eq = '=' sp ;
slash = '/' sp ;
semi = ';' sp ;
col = ':' sp ;

sp =
  (
    [\r\n\ ]+
  / '//' [^ \n]* '\n'
  / '/*' (!'*/' any)* '*/'
  )*
;

any = { _P.step(true) } ;

