{
  function asSeq(atoms) {
    if(atoms.length > 1) return { seq: atoms }
    return atoms[0]
  }
  function atom(bind, expr, op) {
    var el =
      op == '+' ? { many: expr }
      : op == '*' ? { any: expr }
      : op == '?' ? { opt: expr }
      : expr
    if(bind) el.bind = bind
    return el
  }
  function cat(arr) {
    return arr.join('')
  }
}


Start =
  sp
  init:JSEmbed?
  rules:Rule+
  { rules }
;

Rule =
  name:RuleHead
  eq
  def:Expr
  semi
  { name: name, def: def }
;

RuleHead = n:word sp { n } ;

Expr =
  left:ExprAction
  r:(
    tail:(
      slash 
      e:ExprAction {e}
      )+
    { alt: [left].concat(tail) }
  /
    { left }
  )
  { r }
;

ExprAction =
  body:ExprSeq
  r:(
    isobj:JSIsObj
    format:JSEmbed
    { format: isobj ? '{' + format + '}' : format, of: body }
  /
    { body }
  )
  { r }
;

ExprSeq =
  atoms:ExprAtom*
  { asSeq(atoms) }
;

ExprAtom =
  bind:(n:word col {n})?
  expr:( Ref / Range / Literal / ExprParens )
  op:[?*+]? sp
  { atom(bind, expr, op) }
/ 
  op:[&!]
  expr:( Ref / Range / Literal / ExprParens )
  { lookahead: expr, not: op == '!' }
;

Ref = n:word { ref: n } ;
Range = r:rangelit { range: r } ;
Literal = s:str { str: s } ;
ExprParens = '(' sp e:Expr ')' sp { e } ;

JSEmbed =
  '{' sp
  e:embed
  '}' sp
  { e }
;

JSIsObj =
  &( '{' sp word sp col )
  { true }
/
  { false }
;

word = [a-z A-Z _][a-z A-Z 0-9 _]* ;

str = 
  ["] x:('\\' any / [^"])* ["] { x }
/ ['] x:('\\' any / [^'])* ['] { x }
;

rangelit =
  '['
  not:'^'? sp
  rs:(
    from:rangechar '-' to:rangechar sp
    { from: from, to: to }
  / 
    chars:( c:rangechar+ sp { cat(c) } )+
    { oneof: cat(chars) }
  )*
  ']' sp
  { range: rs, not: not == '^' }
;

rangechar = '\\' any / [^\[\] ] ;

embed =  [^{}]* ( '{' embed '}' [^{}]* )* ;

eq = '=' sp ;
slash = '/' sp ;
semi = ';' sp ;
col = ':' sp ;

any = { _P.step(true) } ;

sp = [\r\n\ ]* ;

lsp =
  (
    [\r\n\ ]+
  / '//' [^ \n]* '\n'
  )*
;
