{
  function asSeq(atoms) {
    return { seq: atoms }
  }
  function atom(bind, expr, op) {
    var el =
      op == '+' ? { many: expr }
      : op == '*' ? { any: expr }
      : op == '?' ? { opt: expr }
      : expr
    if(bind) el.set = bind
    return el
  }
}


Start =
  sp
  // init:embed?
  rules:Rule+
  { rules }
;

Rule =
  name:RuleHead
  eq
  def:Expr
  semi
  { name: name, def: def }
;

RuleHead = n:word sp { n } ;

Expr =
  left:ExprAction
  r:(
    tail:(
      slash 
      e:ExprAction {e}
      )+
    { alt: [left].concat(tail) }
  /
    { left }
  )
  { r }
;

ExprAction =
  body:ExprSeq
  r:(
    format:ExprFormat
    { format: format, of: body }
  /
    { body }
  )
  { r }
;

ExprFormat =
  '{' sp
  f:JSEmbed
  '}' sp
  { f }
;

ExprSeq =
  atoms:ExprAtom*
  { asSeq(atoms) }
;

ExprAtom =
  bind:(n:word col {n})?
  expr:(
    Ref / Range / Literal
  / ExprParens
  )
  op:[?*+]? sp
  { atom(bind, expr, op) }
;

Ref = n:word { ref: n } ;
Range = '<>' { range: '<>' } ; // TODO
Literal = s:str { str: s } ;
ExprParens = '(' sp e:expr ')' { e } ;


word = [a-z A-Z _][a-z A-Z 0-9 _]* ;

str = 
  ["] x:[^"]* ["] { x }
/ ['] x:[^']* ['] { x }
;
// str =
//   ['] x:[(\\.|[^'])*] ['] sp {{ str: x }}
// / ["] x:[(\\.|[^"])*] ["] sp {{ str: x }}


JSEmbed =  [^{}]* ( '{' JSEmbed '}' [^{}]* )* ;


eq = '=' sp ;
slash = '/' sp ;
semi = ';' sp ;
col = ':' sp ;
comma = ',' ;


sp = [\r\n\ ]* ;

lsp =
  (
    [\r\n\ ]+
  / '//' [^ \n]* '\n'
  )*
;
